import * as THREE from 'three';
import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
// Import the configuration
import { sceneConfigurations } from './config.js';


let controls = null;
let renderer = null;
let scene = null;
let camera = null;

function setup() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    scene.fog = new THREE.FogExp2(0x1a1a1a, 0.002);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, -3, 1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('viewer').appendChild(renderer.domElement);

    // 2. Trackball Controls
    controls = new TrackballControls(camera, renderer.domElement);
    controls.rotateSpeed = 2.5;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;
    controls.staticMoving = false; // Set false for a "sliding" feel

    // 3. Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    // Create the light
    const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);

    // Position it relative to the camera
    // (e.g., slightly above and to the right of the lens)
    dirLight.position.set(0.5, -3.5, 1.5);

    // Attach the light to the camera
    camera.add(dirLight);

    // Attach the light's target to the camera
    // By default, target is at (0,0,0). Adding it to the camera
    // and moving it to (0,0,-1) makes the light point straight ahead.
    dirLight.target.position.set(0, 0, -1);
    camera.add(dirLight.target);

    // CRITICAL: Add the camera to the scene so its children render
    scene.add(camera);
}

const loadedPivots = []; // Track the containers
const loadedMeshes = []; // Array to store all loaded mesh objects
const loader = new PLYLoader();

function loadScene() {
    // 1. CLEANUP
    loadedPivots.forEach(pivot => {
        // Traverse to find meshes and dispose of GPU assets
        pivot.traverse(node => {
            if (node.isMesh || node.isLineSegments) {
                node.geometry.dispose();
                node.material.dispose();
            }
        });
        scene.remove(pivot);
    });

    // Reset our tracking arrays
    loadedPivots.length = 0;
    loadedMeshes.length = 0;

    // 4. PLY Loader Implementation    
    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.getElementById('progress-container');

    progressContainer.style.display = 'block';

    // 1. Setup Data

    // 3. Loop through the array and load each model
    let percent = [];
    config.models.forEach((modelData, i) => {
        loader.load(modelData.path, (geometry) => {
            geometry.computeVertexNormals();

            // Randomize color slightly or use a fixed one
            const material = new THREE.MeshStandardMaterial({
                color: modelData.color ?? 0xffffff,
                flatShading: false,
                // Add these three lines:
                polygonOffset: modelData.wire ? true : false,
                polygonOffsetFactor: modelData.wire ? 1 : 0,
                polygonOffsetUnits: modelData.wire ? 1 : 0
            });

            const mesh = new THREE.Mesh(geometry, material);

            if (modelData.wire) {
                // 1. Create Wireframe Geometry (Shows all triangles)
                const wireframeGeom = new THREE.WireframeGeometry(mesh.geometry);

                // 2. Create the material
                const wireframeMaterial = new THREE.LineBasicMaterial({
                    color: 0x505050,
                    transparent: true,
                    opacity: 0.15
                });

                // 3. Create the lines
                const wireframe = new THREE.LineSegments(wireframeGeom, wireframeMaterial);

                // 4. Add to mesh so it follows oscillation and rotation
                mesh.add(wireframe);
            }

            // We are NOT centering them, so they stay in their relative exported positions
            // Create a Pivot Group
            const pivot = new THREE.Group();
            scene.add(pivot);
            pivot.add(mesh); // The mesh is now a child of the pivot

            loadedPivots.push(pivot);
            loadedMeshes.push(mesh);

            // Store the whole config object for later use
            mesh.userData = modelData;

            if (loadedMeshes.length === config.models.length) {
                progressContainer.style.display = 'none'; // Hide when all are done
            }

        }, (xhr) => {
            // Handle Loading Progress
            percent[i] = ((xhr.loaded / xhr.total) * 100);
            let p = percent.reduce((accumulator, current) => accumulator + current, 0) / config.models.length;
            progressBar.style.width = p + '%';
            progressBar.innerText = Math.round(p) + '%';
        }, (error) => {
            console.error('Error loading PLY:', error);
            progressBar.classList.replace('bg-info', 'bg-danger');
            progressBar.innerText = "Error Loading File";
        });
    });
}

// 5. Animation & Resize
function animate(time) {

    requestAnimationFrame(animate);

    controls.update();
    renderer.render(scene, camera);


    if (loadedMeshes.length < config.models.length) {
        return;
    }

    const t = time * 0.002;

    if (autoRotate) {
        loadedPivots.forEach(pivot => {
            pivot.rotation.z += config.autoRotateSpeed ?? 0.01;
        });
    }

    loadedMeshes.forEach(mesh => {
        if (mesh.userData.animate) {
            mesh.userData.animate(mesh, t);
        }
    });
}

// --- URL Parameter Logic ---
const urlParams = new URLSearchParams(window.location.search);
const modelIndex = parseInt(urlParams.get('model')) || 0;

// Ensure the index exists in our config, otherwise default to 0
const configIndex = (modelIndex >= 0 && modelIndex < sceneConfigurations.length) ? modelIndex : 0;
let config = sceneConfigurations[configIndex];

const sceneList = document.getElementById('sceneList');

sceneConfigurations.forEach((cfg, index) => {
    const li = document.createElement('li');
    li.innerHTML = `<a class="dropdown-item" href="#">${cfg.name}</a>`;
    li.onclick = () => {
        config = sceneConfigurations[index];
        loadScene();
    }
    sceneList.appendChild(li);
});

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    controls.handleResize(); // Required for TrackballControls
});

let autoRotate = true; // Track state

// Listen for the toggle change
document.getElementById('autoRotateSwitch').addEventListener('change', (e) => {
    autoRotate = e.target.checked;
});

setup();

loadScene();

requestAnimationFrame(animate);